# 1 (After chapter 17)

# 강의노트 - 배열 데이터를 효과적으로 다루는 NumPy

# Terminal >> pip install numpy


# 배열 : 동일 데이터 타입, 엘리먼트의 크기가 다 똑같다.

# 배열 생성하기

####################################################
#  시퀀스 데이터로부터 배열 생성
#   ○ arr_obj = np.array(seq_data)
#        시퀀스 데이터(리스트, 튜플 등)를 배열로 변경
#   ○ 배열의 속성
#        dtype : 배열 요소의 데이터 타입
#        shape : 배열의 모양(차원)을 튜플로 표현

import numpy as np

data1 = [0, 1, 2, 3, 4, 5]
a1 = np.array(data1)
print(a1)

data2 = [0.1, 5, 4, 12, 0.5]
a2 = np.array(data2)
print(a2)

print(a1.dtype)
print(a2.dtype)

"""
[0 1 2 3 4 5]
[ 0.1  5.   4.  12.   0.5]
int32
float64
"""

print(np.array([0.5, 2, 0.01, 8]))
print(np.array([[1,2,3],[4,5,6],[7,8,9]]))

"""
[0.5  2.   0.01 8.  ]
[[1 2 3]
 [4 5 6]
 [7 8 9]]
"""

# numpy 모듈 학습 때는 PyCharm이 불편하다.


# 명령창
# >> cd \workspace\01_python\numpy-ex
# >> conda activate numpy-ex  # 가상환경 활성화
# >> jupyter notebook
# New -> Python3 -> 파일명: ex01

# shift + Enter : 실행
# 강의자료 표현과 같다.

# Heading 에서 ## 소제목 # 큰제목
# Markdown 에서 넘버링 이후 - 로 들여쓰기 된다.





####################################################
#  범위를 지정해 배열 생성(1)
#   ○ arr_obj = np.arange([start, ] stop[, step])
#        start부터 stop 전까지 step만큼 더해 배열을 생성
#        start 디폴트는 0
#        step 디폴트는 1

print(np.arange(0, 10, 2))

print(np.arange(1, 10))

print(np.arange(5))

"""
[0 2 4 6 8]
[1 2 3 4 5 6 7 8 9]
[0 1 2 3 4]
"""

####################################################
#  범위를 지정해 배열 생성(2)
#   ○ reshape(m, n)
#        배열의 차원 조정
#        m x n 행태로 변경
#        데이터의 개수가 맞아야 함

print(np.arange(12).reshape(4,3))

b1 = np.arange(12).reshape(4,3)
print(b1.shape)

b2 = np.arange(5)
print(b2.shape)

"""
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
(4, 3)
(5,)
"""

# 원본에 영향을 미치지 않음

####################################################
#  범위를 지정해 배열 생성(3)
#   ○ arr_obj = np.linspace(start, stop[, num])
#        start부터 stop까지(포함) num개의 NumPy 배열 생성
#        num 디폴트 값은 1

print(np.linspace(1, 10, 10))

print(np.linspace(0, np.pi, 20 ))

"""
[ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]
[0.         0.16534698 0.33069396 0.49604095 0.66138793 0.82673491
 0.99208189 1.15742887 1.32277585 1.48812284 1.65346982 1.8188168
 1.98416378 2.14951076 2.31485774 2.48020473 2.64555171 2.81089869
 2.97624567 3.14159265]
"""

####################################################
#  특별한 형태의 배열 생성(1)
#   ○ arr_zero_n = np.zeros(n)
#   ○ arr_zero_mxn = np.zeros((m,n))
#        원소가 0인 배열 생성
#   ○ arr_one_n = np.ones(n)
#   ○ arr_one_mxn = np.ones((m,n))
#        원소가 1인 배열 생성

print(np.zeros(10))
print(np.zeros((3,4)))
print(np.ones(5))
print(np.ones((3,5)))

"""
[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
[[0. 0. 0. 0.]
 [0. 0. 0. 0.]
 [0. 0. 0. 0.]]
[1. 1. 1. 1. 1.]
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
"""

####################################################
#  특별한 형태의 배열 생성(2)
#   ○ arr_I = np.eye(n)
#        n x n 단위 행렬 생성

print(np.eye(3))

"""
[[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]
"""


####################################################
#  배열의 데이터 타입 변환
#     ○ 배열의 데이터 타입 기호
#          b : 불
#          i : 부호가 있는 정수
#          u : 부호가 없는 정수
#          f : 실수
#          c : 복소수
#          M : 날짜
#          O : 파이썬 객체
#          S 혹은 a : 바이트 배열
#          U : 유니코드
#     ○ 데이터 타입의 숫자
#          비트 수 혹은 바이트 수
#     ○ 예 'U8' : 8비트 유니코드
#          'i32' : 32비트 부호 있는 정수
#
#     ○ arr_obj = np.astype(타입)
#          배열을 지정한 타입으로 변환

print(np.array(['1.5', '0.62', '2', '3.14', '3.141592']))  # 문자열

str_a1 = np.array(['1.567', '0.123', '5.123', '9', '8'])
num_a1 = str_a1.astype(float)
print(num_a1)

print(str_a1.dtype)
print(num_a1.dtype)

"""
['1.5' '0.62' '2' '3.14' '3.141592']
[1.567 0.123 5.123 9.    8.   ]
<U5
float64
"""

str_a2 = np.array(['1', '3', '5', '7', '9'])
num_a2 = str_a2.astype(int)
print(num_a2)

print(str_a2.dtype)
print(num_a2.dtype)

"""
[1 3 5 7 9]
<U1
int32
"""

num_f1 = np.array([10, 21, 0.549, 4.75, 5.98])
num_i1 = num_f1.astype(int)
print(num_i1)

print(num_f1.dtype)
print(num_i1.dtype)

"""
[10 21  0  4  5]
float64
int32
"""


####################################################
#  난수 배열의 생성
#   ○ np.random.seed(시드값)
#        난수 생성 시드값 설정
#   ○ rand_num = np.random.rand()
#        [0. 1) 사이의 실수 난수 생성
#   ○ rand_num = np.random.rand([d0, d1, …, dn])
#        지정한 차원의 배열 생성
#        [0. 1) 사이의 실수 난수로 채움
#   ○ rand_num = np.random.randn([d0, d1, …, dn])
#        지정한 차원의 배열 생성
#        가우시안 표준 정규 분포를 따르는 실수 난수 채움
#   ○ rand_num = np.random.randint([low,] high, [,size])
#        [low, high)사이의 정수 난수를 갖는 배열 생성
#        size는 배열의 크기
#           ⁃ 튜플로 지정 (d0, d1, … , dn)
#        low의 디폴트 값은 0

print(np.random.rand(2,3))
print(np.random.rand())
print(np.random.rand(2,3,4))

"""
[[0.519806   0.63103442 0.08492629]
 [0.70777859 0.92953089 0.87556219]]
0.5879415502711902
[[[0.06438198 0.9181414  0.41464336 0.45569278]
  [0.84852853 0.60178245 0.02018217 0.34204117]
  [0.19612145 0.70488253 0.28522807 0.99732704]]

 [[0.19970462 0.65085597 0.38138126 0.56935608]
  [0.15681528 0.70084498 0.96037466 0.04621748]
  [0.90568712 0.98013321 0.27448188 0.01700596]]]
"""

print(np.random.randint(10, size=(3, 4)))
print(np.random.randint(1, 30))

"""
[[1 2 9 6]
 [3 2 7 4]
 [8 4 2 7]]
26
"""


####################################################
# 배열의 연산
####################################################
#  기본 연산

arr1 = np.array([10, 20, 30, 40])
arr2 = np.array([1, 2, 3, 4])
print(arr1 + arr2)
print(arr1 - arr2)
print(arr1 * 2)
print(arr1 ** 2)
print(arr1 / arr2)
print(arr1 / (arr2**2))
print(arr1 > 20)

"""
[11 22 33 44]
[ 9 18 27 36]
[20 40 60 80]
[ 100  400  900 1600]
[10. 10. 10. 10.]
[10.          5.          3.33333333  2.5       ]
[False False  True  True]
"""

####################################################
#  통계를 위한 연산,  행렬 연산 (넘어감)

####################################################
# 배열의 인덱싱과 슬라이싱
####################################################
#  배열의 인덱싱
#   ○ 배열명[위치]
#   ○ 배열명[[위치1, 위치2, …, 위치n]]
#        해당 차원의 여러 원소 선택
#   ○ 배열명[행_위치, 열_위치]
#   ○ 배열명[ [행_위치1, 행_위치2, … , 행_위치n],
#             [열_위치1, 열_위치2, … , 열_위치n]]  # 이 형태가 뭔가 이상한듯???
#        2차원 배열의 여러 원소를 선택
#   ○ 배열명[조건식]
#        해당 조건식을 만족하는 원소만 선택된 배열

a1 = np.array([0, 10, 20, 30, 40, 50])
print(a1)
print(a1[0])
print(a1[4])

a1[5] = 70
print(a1)

print(a1[[1,3,4]])  # 1차원을 다루겠다. 1차원에서 1,3,4의 index를 찾는다.
                    # 여러개를 꺼내주는 것이다.

"""
[ 0 10 20 30 40 50]
0
40
[ 0 10 20 30 40 70]
[10 30 40]
"""

a2 = np.arange(10, 100, 10).reshape(3,3)
print(a2)

print(a2[0, 2])

a2[2, 2] = 95
print(a2)

print(a2[1])

print()

a2[1] = np.array([45, 55, 65])
print(a2)

a2[1] = [47, 57, 67]
print(a2)

print(a2[[0, 2], [0, 1]])

"""
[[10 20 30]
 [40 50 60]
 [70 80 90]]
30
[[10 20 30]
 [40 50 60]
 [70 80 95]]
[40 50 60]

[[10 20 30]
 [45 55 65]
 [70 80 95]]
[[10 20 30]
 [47 57 67]
 [70 80 95]]
[10 80]
"""

a = np.array([1, 2, 3, 4, 5, 6])
print(a[a > 3])

print(a[(a % 2) == 0])

"""
[4 5 6]
[2 4 6]
"""

####################################################
#  배열의 슬라이싱
#   ○ 배열[시작_위치:끝_위치]
#        시작_위치 ~ 끝_위치-1 범위의 슬라이싱
#        시작_위치 생략시 0
#        끝_위치 생략시 배열의 끝
#   ○ 배열[행시작_위치:행끝_위치, 열시작_위치:열끝_위치]
#        2차원의 슬라이싱

b1 = np.array([0, 10, 20, 30, 40, 50])
print(b1[1:4])
print(b1[:3])
print(b1[2:])

b1[2:5] = np.array([25, 35, 45])
print(b1)

b1[3:6] = 60
print(b1)

"""
[10 20 30]
[ 0 10 20]
[20 30 40 50]
[ 0 10 25 35 45 50]
[ 0 10 25 60 60 60]
"""

b2 = np.arange(10, 100, 10).reshape(3,3)
print(b2)

print(b2[1:3, 1:3])

print(b2[:3, 1:])

print(b2[1][0:2])

b2[0:2, 1:3] = np.array([[25, 35], [55, 65]])
print(b2)

"""
[[10 20 30]
 [40 50 60]
 [70 80 90]]
[[50 60]
 [80 90]]
[[20 30]
 [50 60]
 [80 90]]
[40 50]
[[10 25 35]
 [40 55 65]
 [70 80 90]]
"""

# jupyter는 결과를 바로 볼 수 있다.